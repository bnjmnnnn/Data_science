import polars as pl

def limpiar_datos_pokemon(ruta_archivo):
    """
    Limpia y valida datos de Pok√©mon de primera generaci√≥n
    """
    
    # Leer el archivo CSV
    try:
        df = pl.read_csv(ruta_archivo)
        print(f"‚úÖ Archivo le√≠do exitosamente: {df.shape[0]} filas, {df.shape[1]} columnas")
        print(f"Columnas encontradas: {df.columns}")
    except Exception as e:
        print(f"‚ùå Error al leer el archivo: {e}")
        return None
    
    print("\n" + "="*60)
    print("AN√ÅLISIS INICIAL DE DATOS")
    print("="*60)
    
    # Mostrar informaci√≥n b√°sica
    print(df.describe())
    print(f"\nPrimeras 5 filas:")
    print(df.head())
    
    # Pok√©mon v√°lidos de primera generaci√≥n (1-151)
    pokemon_gen1 = {
        'Bulbasaur', 'Ivysaur', 'Venusaur', 'Charmander', 'Charmeleon', 'Charizard',
        'Squirtle', 'Wartortle', 'Blastoise', 'Caterpie', 'Metapod', 'Butterfree',
        'Weedle', 'Kakuna', 'Beedrill', 'Pidgey', 'Pidgeotto', 'Pidgeot',
        'Rattata', 'Raticate', 'Spearow', 'Fearow', 'Ekans', 'Arbok',
        'Pikachu', 'Raichu', 'Sandshrew', 'Sandslash', 'Nidoran‚ôÄ', 'Nidorina',
        'Nidoqueen', 'Nidoran‚ôÇ', 'Nidorino', 'Nidoking', 'Clefairy', 'Clefable',
        'Vulpix', 'Ninetales', 'Jigglypuff', 'Wigglytuff', 'Zubat', 'Golbat',
        'Oddish', 'Gloom', 'Vileplume', 'Paras', 'Parasect', 'Venonat',
        'Venomoth', 'Diglett', 'Dugtrio', 'Meowth', 'Persian', 'Psyduck',
        'Golduck', 'Mankey', 'Primeape', 'Growlithe', 'Arcanine', 'Poliwag',
        'Poliwhirl', 'Poliwrath', 'Abra', 'Kadabra', 'Alakazam', 'Machop',
        'Machoke', 'Machamp', 'Bellsprout', 'Weepinbell', 'Victreebel', 'Tentacool',
        'Tentacruel', 'Geodude', 'Graveler', 'Golem', 'Ponyta', 'Rapidash',
        'Slowpoke', 'Slowbro', 'Magnemite', 'Magneton', 'Farfetch\'d', 'Doduo',
        'Dodrio', 'Seel', 'Dewgong', 'Grimer', 'Muk', 'Shellder',
        'Cloyster', 'Gastly', 'Haunter', 'Gengar', 'Onix', 'Drowzee',
        'Hypno', 'Krabby', 'Kingler', 'Voltorb', 'Electrode', 'Exeggcute',
        'Exeggutor', 'Cubone', 'Marowak', 'Hitmonlee', 'Hitmonchan', 'Lickitung',
        'Koffing', 'Weezing', 'Rhyhorn', 'Rhydon', 'Chansey', 'Tangela',
        'Kangaskhan', 'Horsea', 'Seadra', 'Goldeen', 'Seaking', 'Staryu',
        'Starmie', 'Mr. Mime', 'Scyther', 'Jynx', 'Electabuzz', 'Magmar',
        'Pinsir', 'Tauros', 'Magikarp', 'Gyarados', 'Lapras', 'Ditto',
        'Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Porygon', 'Omanyte',
        'Omastar', 'Kabuto', 'Kabutops', 'Aerodactyl', 'Snorlax', 'Articuno',
        'Zapdos', 'Moltres', 'Dratini', 'Dragonair', 'Dragonite', 'Mewtwo', 'Mew'
    }
    
    # ‚ùå SOLO TIPOS DE GEN 1 - NO INCLUYE HADA/FAIRY
    tipos_validos = {
        'Normal', 'Fuego', 'Agua', 'El√©ctrico', 'Planta', 'Hielo', 'Lucha',
        'Veneno', 'Tierra', 'Volador', 'Psiquico', 'Bicho', 'Roca', 'Fantasma', 'Drag√≥n',
        # Tambi√©n en ingl√©s por si acaso
        'Fire', 'Water', 'Electric', 'Grass', 'Ice', 'Fighting',
        'Poison', 'Ground', 'Flying', 'Psychic', 'Bug', 'Rock', 'Ghost', 'Dragon'
    }
    
    print("\n" + "="*60)
    print("DETECCI√ìN DE PROBLEMAS")
    print("="*60)
    
    problemas_encontrados = []
    
    # ‚úÖ DETECCI√ìN DE COLUMNAS CORREGIDA - Mapeo directo por nombre exacto
    col_nombre = 'Nombre' if 'Nombre' in df.columns else None
    col_tipo1 = 'Tipo 1' if 'Tipo 1' in df.columns else None
    col_tipo2 = 'Tipo 2' if 'Tipo 2' in df.columns else None
    col_ataque = 'Ataque' if 'Ataque' in df.columns else None
    col_defensa = 'Defensa' if 'Defensa' in df.columns else None
    col_velocidad = 'Velocidad' if 'Velocidad' in df.columns else None
    col_hp = 'PS' if 'PS' in df.columns else None
    
    print(f"Columnas identificadas:")
    print(f"  Nombre: {col_nombre}")
    print(f"  Tipo 1: {col_tipo1}")
    print(f"  Tipo 2: {col_tipo2}")
    print(f"  Ataque: {col_ataque}")
    print(f"  Defensa: {col_defensa}")
    print(f"  Velocidad: {col_velocidad}")
    print(f"  HP/PS: {col_hp}")
    
    # 1. Valores nulos o vac√≠os
    if col_nombre:
        nulos_nombre = df.filter(pl.col(col_nombre).is_null() | (pl.col(col_nombre) == "")).height
        if nulos_nombre > 0:
            problemas_encontrados.append(f"‚ùå {nulos_nombre} filas con nombres nulos o vac√≠os")
            print(f"‚ùå {nulos_nombre} filas con nombres nulos o vac√≠os")
    
    # 2. Validar nombres de Pok√©mon de Gen 1
    if col_nombre:
        df_validacion = df.with_columns([
            pl.col(col_nombre).is_in(pokemon_gen1).alias("pokemon_valido")
        ])
        nombres_invalidos = df_validacion.filter(~pl.col("pokemon_valido"))
        if nombres_invalidos.height > 0:
            problemas_encontrados.append(f"‚ùå {nombres_invalidos.height} Pok√©mon no v√°lidos de Gen 1")
            print(f"‚ùå {nombres_invalidos.height} Pok√©mon no v√°lidos de Gen 1:")
            print(nombres_invalidos.select([col_nombre]).unique())
    
    # 3. Validar tipos - AQU√ç SE VA A DETECTAR HADA COMO INV√ÅLIDO
    if col_tipo1:
        tipos_unicos1 = df.filter(pl.col(col_tipo1).is_not_null()).select(pl.col(col_tipo1).unique()).to_series().to_list()
        print(f"\nüîç Tipos primarios encontrados en tu archivo: {tipos_unicos1}")
        
        tipos_invalidos1 = df.filter(
            ~pl.col(col_tipo1).is_in(tipos_validos) & 
            pl.col(col_tipo1).is_not_null()
        )
        
        if tipos_invalidos1.height > 0:
            tipos_malos = tipos_invalidos1.select(pl.col(col_tipo1).unique()).to_series().to_list()
            problemas_encontrados.append(f"‚ùå {tipos_invalidos1.height} filas con tipos primarios inv√°lidos")
            print(f"‚ùå {tipos_invalidos1.height} filas con tipos primarios inv√°lidos")
            print(f"   Tipos inv√°lidos encontrados: {tipos_malos}")
            
            # Mostrar qu√© Pok√©mon tienen estos tipos inv√°lidos
            if col_nombre:
                pokemon_con_tipos_malos = tipos_invalidos1.select([col_nombre, col_tipo1]).unique()
                print(f"   Pok√©mon afectados:")
                print(pokemon_con_tipos_malos)
    else:
        print("‚ö†Ô∏è No se pudo detectar la columna 'Tipo 1'")
    
    if col_tipo2:
        tipos_unicos2 = df.filter(pl.col(col_tipo2).is_not_null() & (pl.col(col_tipo2) != "")).select(pl.col(col_tipo2).unique()).to_series().to_list()
        print(f"üîç Tipos secundarios encontrados en tu archivo: {tipos_unicos2}")
        
        tipos_invalidos2 = df.filter(
            ~pl.col(col_tipo2).is_in(tipos_validos) & 
            pl.col(col_tipo2).is_not_null() & 
            (pl.col(col_tipo2) != "")
        )
        
        if tipos_invalidos2.height > 0:
            tipos_malos2 = tipos_invalidos2.select(pl.col(col_tipo2).unique()).to_series().to_list()
            problemas_encontrados.append(f"‚ùå {tipos_invalidos2.height} filas con tipos secundarios inv√°lidos")
            print(f"‚ùå {tipos_invalidos2.height} filas con tipos secundarios inv√°lidos")
            print(f"   Tipos inv√°lidos encontrados: {tipos_malos2}")
    else:
        print("‚ö†Ô∏è No se pudo detectar la columna 'Tipo 2'")
    
    # 4. Validar estad√≠sticas
    columnas_stats = [
        (col_ataque, "Ataque", 1, 255),
        (col_defensa, "Defensa", 1, 255),
        (col_velocidad, "Velocidad", 1, 255),
        (col_hp, "HP/PS", 1, 255)
    ]
    
    for col, nombre, min_val, max_val in columnas_stats:
        if col:
            # Valores nulos
            nulos = df.filter(pl.col(col).is_null()).height
            if nulos > 0:
                problemas_encontrados.append(f"‚ùå {nulos} valores nulos en {nombre}")
                print(f"‚ùå {nulos} valores nulos en {nombre}")
            
            # Valores fuera de rango
            fuera_rango = df.filter(
                (pl.col(col) < min_val) | (pl.col(col) > max_val)
            ).height
            if fuera_rango > 0:
                problemas_encontrados.append(f"‚ùå {fuera_rango} valores de {nombre} fuera del rango ({min_val}-{max_val})")
                print(f"‚ùå {fuera_rango} valores de {nombre} fuera del rango ({min_val}-{max_val})")
    
    # 5. Duplicados
    if col_nombre:
        duplicados = df.group_by(col_nombre).len().filter(pl.col("len") > 1)
        if duplicados.height > 0:
            problemas_encontrados.append(f"‚ùå {duplicados.height} Pok√©mon duplicados")
            print(f"‚ùå {duplicados.height} Pok√©mon duplicados:")
            print(duplicados)
    
    print("\n" + "="*60)
    print("RESUMEN DE LIMPIEZA")
    print("="*60)
    
    if not problemas_encontrados:
        print("‚úÖ ¬°Perfecto! No se encontraron problemas en los datos.")
        return df
    else:
        print(f"Se encontraron {len(problemas_encontrados)} tipos de problemas:")
        for problema in problemas_encontrados:
            print(f"  {problema}")
    
    # Crear DataFrame limpio ELIMINANDO TIPOS INV√ÅLIDOS
    print("\nüßπ Creando dataset limpio (ELIMINANDO tipos Hada/Fairy)...")
    
    condiciones_limpieza = []
    
    if col_nombre:
        condiciones_limpieza.append(pl.col(col_nombre).is_not_null())
        condiciones_limpieza.append(pl.col(col_nombre) != "")
        condiciones_limpieza.append(pl.col(col_nombre).is_in(pokemon_gen1))
    
    # ESTA ES LA PARTE CR√çTICA - ELIMINA FILAS CON TIPOS INV√ÅLIDOS
    if col_tipo1:
        condiciones_limpieza.append(pl.col(col_tipo1).is_in(tipos_validos))
    
    if col_tipo2:
        # Para tipo2, permitir nulos o vac√≠os, pero si tiene valor debe ser v√°lido
        condiciones_limpieza.append(
            (pl.col(col_tipo2).is_null()) | 
            (pl.col(col_tipo2) == "") | 
            (pl.col(col_tipo2).is_in(tipos_validos))
        )
    
    # Aplicar filtros
    if condiciones_limpieza:
        # üîç IDENTIFICAR QU√â FILAS SE VAN A ELIMINAR ANTES DE HACERLO
        filas_validas = pl.all_horizontal(condiciones_limpieza)
        df_limpio = df.filter(filas_validas)
        df_eliminadas = df.filter(~filas_validas)  # ‚Üê Las que NO cumplen las condiciones
        
        # Remover duplicados
        duplicados_eliminados = None
        if col_nombre:
            # Identificar duplicados antes de eliminar
            antes_duplicados = df_limpio.shape[0]
            duplicados_encontrados = df_limpio.group_by(col_nombre).len().filter(pl.col("len") > 1)
            if duplicados_encontrados.height > 0:
                print(f"\nüîç Duplicados que se van a eliminar:")
                print(duplicados_encontrados)
                # Guardar los duplicados que se eliminan
                duplicados_eliminados = df_limpio.group_by(col_nombre).tail(n=-1)  # Todos excepto el primero
                
            df_limpio = df_limpio.unique(subset=[col_nombre], keep="first")
            despues_duplicados = df_limpio.shape[0]
            duplicados_removidos = antes_duplicados - despues_duplicados
        
        filas_eliminadas_total = df.shape[0] - df_limpio.shape[0]
        print(f"‚úÖ Dataset limpio creado: {df_limpio.shape[0]} filas")
        print(f"üóëÔ∏è TOTAL ELIMINADAS: {filas_eliminadas_total} filas")
        
        # üìã MOSTRAR DETALLES DE LO QUE SE ELIMIN√ì
        if df_eliminadas.height > 0:
            print(f"\nüìã DETALLES DE LAS {df_eliminadas.height} FILAS ELIMINADAS POR DATOS INV√ÅLIDOS:")
            
            if col_nombre and col_tipo1:
                eliminadas_detalle = df_eliminadas.select([col_nombre, col_tipo1, col_tipo2] if col_tipo2 else [col_nombre, col_tipo1])
                print(eliminadas_detalle)
                
                # Agrupar por raz√≥n de eliminaci√≥n
                print(f"\nüîç RAZONES DE ELIMINACI√ìN:")
                
                # Pok√©mon no v√°lidos
                pokemon_invalidos = df_eliminadas.filter(~pl.col(col_nombre).is_in(pokemon_gen1))
                if pokemon_invalidos.height > 0:
                    print(f"  ‚Ä¢ {pokemon_invalidos.height} Pok√©mon no v√°lidos de Gen 1:")
                    print(f"    {pokemon_invalidos.select(col_nombre).unique().to_series().to_list()}")
                
                # Tipos inv√°lidos
                if col_tipo1:
                    tipos1_invalidos = df_eliminadas.filter(~pl.col(col_tipo1).is_in(tipos_validos))
                    if tipos1_invalidos.height > 0:
                        tipos_malos_eliminados = tipos1_invalidos.select(pl.col(col_tipo1).unique()).to_series().to_list()
                        print(f"  ‚Ä¢ {tipos1_invalidos.height} filas con Tipo 1 inv√°lido: {tipos_malos_eliminados}")
                        
                        # Mostrar qu√© Pok√©mon espec√≠ficos
                        pokemon_tipo1_malo = tipos1_invalidos.select([col_nombre, col_tipo1]).unique()
                        print(f"    Pok√©mon afectados:")
                        for row in pokemon_tipo1_malo.iter_rows():
                            print(f"      - {row[0]}: {row[1]}")
                
                if col_tipo2:
                    tipos2_invalidos = df_eliminadas.filter(
                        ~pl.col(col_tipo2).is_in(tipos_validos) & 
                        pl.col(col_tipo2).is_not_null() & 
                        (pl.col(col_tipo2) != "")
                    )
                    if tipos2_invalidos.height > 0:
                        tipos_malos2_eliminados = tipos2_invalidos.select(pl.col(col_tipo2).unique()).to_series().to_list()
                        print(f"  ‚Ä¢ {tipos2_invalidos.height} filas con Tipo 2 inv√°lido: {tipos_malos2_eliminados}")
        
        # Mostrar duplicados eliminados
        if col_nombre and duplicados_removidos > 0:
            print(f"\nüìã DUPLICADOS ELIMINADOS: {duplicados_removidos} filas")
            if duplicados_eliminados is not None and duplicados_eliminados.height > 0:
                print("  Pok√©mon duplicados eliminados:")
                print(duplicados_eliminados.select([col_nombre]))
        
        # Guardar dataset limpio
        ruta_salida = ruta_archivo.replace('.csv', '_limpio.csv')
        df_limpio.write_csv(ruta_salida)
        print(f"\nüíæ Dataset limpio guardado en: {ruta_salida}")
        
        # üíæ GUARDAR TAMBI√âN LAS FILAS ELIMINADAS PARA REVISI√ìN
        if df_eliminadas.height > 0:
            ruta_eliminadas = ruta_archivo.replace('.csv', '_eliminadas.csv')
            df_eliminadas.write_csv(ruta_eliminadas)
            print(f"üóëÔ∏è Filas eliminadas guardadas en: {ruta_eliminadas}")
        
        return df_limpio
    else:
        print("‚ö†Ô∏è No se pudieron aplicar filtros de limpieza")
        return df

# Uso del c√≥digo
if __name__ == "__main__":
    # CAMBIA ESTA RUTA POR LA DE TU ARCHIVO
    ruta_archivo = r"c:\Users\benja\OneDrive\Documentos\GitHub\Data_science\Tarea_3\pokemones.csv"
    
    df_limpio = limpiar_datos_pokemon(ruta_archivo)
    
    if df_limpio is not None:
        print("\nüéâ ¬°Proceso de limpieza completado!")
        print(f"Dimensiones finales: {df_limpio.shape}")